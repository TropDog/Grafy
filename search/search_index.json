{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Social Network Analysis Project","text":"<p>Welcome to the documentation for the Social Network Analysis Project! Use the navigation tabs to explore different sections. e <code>code</code> goes here.</p>"},{"location":"data/","title":"Data","text":"<p>The project uses the <code>facebook_combined.txt</code> dataset, which contains connections between friends.</p>"},{"location":"data/#structure-of-facebook_combinedtxt","title":"Structure of facebook_combined.txt","text":"<p>The dataset contains space-separated pairs of user IDs, where each line represents a connection between two users in the social network. The format is as follows:</p> <p>0 1 0 2 0 3 0 4 ...</p> <p>Each line indicates that there is a bidirectional friendship between two users. For example:</p> <p>0 1 means that User 0 is friends with User 1.</p> <p>0 2 means that User 0 is friends with User 2.</p>"},{"location":"data/#how-the-dataset-is-processed","title":"How the Dataset is Processed","text":"<p>The dataset is processed by the DataLoader module, which:</p> <p>Reads the dataset file and loads the connections into memory.</p> <p>Transforms the raw data into a structured format consisting of nodes and edges.</p> <p>Builds a graph representation using the NetworkX library.</p> <p>The transformed data includes:</p> <p>Nodes: A list of unique users in the network.</p> <p>Edges: A list of connections between users.</p>"},{"location":"data/#usage-in-the-project","title":"Usage in the Project","text":"<p>The dataset is used in various parts of the project, including:</p> <p>Finding the shortest path between two users using the shortest_path module.</p> <p>Displaying a user's friends and visualizing their social connections using the show_friends module.</p> <p>Calculating the reach of a social media post using the maximize_reach module.</p>"},{"location":"data/#dataset-size-and-complexity","title":"Dataset Size and Complexity","text":"<p>Number of Users (Nodes): 4,039</p> <p>Number of Connections (Edges): 88,234</p> <p>The dataset is relatively small but complex enough to demonstrate various graph algorithms and visualization techniques.</p>"},{"location":"data/#loading-the-dataset","title":"Loading the Dataset","text":"<p>The dataset is loaded automatically by the main application using the <code>DataLoader</code> class:</p> <pre><code>from app.data_loader import DataLoader\n\nloader = DataLoader(\"data/facebook_combined.txt\")\ndata = loader.load_csv()\n\ntransformed_data = loader.transform_data(data)\n\nprint(transformed_data)\n</code></pre>"},{"location":"requirements/","title":"Project Requirements","text":"<p>This project relies on several Python packages to function correctly. Below is a list of the required dependencies along with a brief description of their purpose.</p>"},{"location":"requirements/#dependencies","title":"Dependencies","text":"Package Version Description <code>networkx</code> 3.1 A library for creating and manipulating complex networks and graphs. <code>pytest</code> 7.4.2 A testing framework to ensure your code works correctly. <code>pytest-cov</code> 4.1.0 A plugin for measuring code coverage during tests. <code>matplotlib</code> Latest A plotting library for creating visualizations. <code>mkdocs-material</code> Latest A theme for MkDocs that provides a modern and responsive design. <code>mkdocstrings[python]</code> Latest A MkDocs plugin for generating API documentation from docstrings."},{"location":"requirements/#installation","title":"Installation","text":"<p>To install the required dependencies, run the following command:</p> <p>```bash pip install -r requirements.txt</p>"},{"location":"tests/","title":"Tests","text":"<p>This section describes how to run tests for the project.</p>"},{"location":"usage/","title":"Introdution","text":"<p>This section serves as a step-by-step guide to help you understand how to use the tools and functionalities provided by  the Social Network Analysis Project. Whether you're looking to conduct basic analyses on graph data, implement  advanced algorithms for node classification or community detection, or visualize network structures to uncover hidden  relationships, this guide covers it all.</p>"},{"location":"workflows/","title":"Workflows","text":"<p>This project uses GitHub Actions to automate continuous integration (CI) and continuous deployment (CD) processes. Below is a detailed description of the workflow used in the project.</p>"},{"location":"workflows/#workflow-python-tests-and-linting","title":"Workflow: Python Tests and Linting","text":"<p>The workflow is defined in the <code>.github/workflows</code> directory as a YAML file. It is triggered on:</p> <ul> <li>Push events to the <code>dev</code> and <code>main</code> branches.</li> <li>Pull requests targeting the <code>dev</code> and <code>main</code> branches.</li> </ul>"},{"location":"workflows/#trigger-conditions","title":"Trigger Conditions","text":"Event Branches <code>push</code> <code>dev</code>, <code>main</code> <code>pull_request</code> <code>dev</code>, <code>main</code>"},{"location":"workflows/#jobs-in-the-workflow","title":"\ud83d\udee0\ufe0f Jobs in the Workflow","text":""},{"location":"workflows/#job-lint-and-test","title":"Job: Lint and Test","text":"<p>The workflow runs a single job called <code>lint-and-test</code> on an Ubuntu virtual machine (<code>ubuntu-latest</code>).</p>"},{"location":"workflows/#steps-in-the-job","title":"Steps in the Job","text":""},{"location":"workflows/#step-1-checkout-code","title":"Step 1: Checkout Code","text":"<p>This step uses the <code>actions/checkout</code> action to clone the repository into the runner.</p> <p>```yaml - name: Checkout code   uses: actions/checkout@v3</p>"},{"location":"tests/conftest/","title":"Configuration Test","text":""},{"location":"tests/conftest/#tests.conftest.large_sample_edges","title":"<code>large_sample_edges()</code>","text":"<p>Provide a large list of sample edges for testing.</p> <p>This fixture returns a list of dictionaries, where each dictionary represents an edge in a graph with keys \"user\" and \"friend\" indicating connected nodes.</p> <p>Returns:</p> Type Description <p>list[dict]: A list of edges represented as dictionaries with \"user\" and \"friend\" keys.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef large_sample_edges():\n    \"\"\"\n    Provide a large list of sample edges for testing.\n\n    This fixture returns a list of dictionaries, where each dictionary represents\n    an edge in a graph with keys \"user\" and \"friend\" indicating connected nodes.\n\n    Returns:\n        list[dict]: A list of edges represented as dictionaries with \"user\" and \"friend\" keys.\n    \"\"\"\n\n    return [\n        {\"user\": \"1\", \"friend\": \"2\"},\n        {\"user\": \"1\", \"friend\": \"3\"},\n        {\"user\": \"1\", \"friend\": \"4\"},\n        {\"user\": \"1\", \"friend\": \"5\"},\n        {\"user\": \"1\", \"friend\": \"6\"},\n        {\"user\": \"2\", \"friend\": \"3\"},\n        {\"user\": \"2\", \"friend\": \"8\"},\n        {\"user\": \"3\", \"friend\": \"9\"},\n        {\"user\": \"4\", \"friend\": \"10\"},\n        {\"user\": \"5\", \"friend\": \"2\"},\n        {\"user\": \"6\", \"friend\": \"10\"},\n        {\"user\": \"7\", \"friend\": \"11\"},\n        {\"user\": \"8\", \"friend\": \"4\"},\n        {\"user\": \"9\", \"friend\": \"5\"},\n        {\"user\": \"10\", \"friend\": \"2\"},\n        {\"user\": \"10\", \"friend\": \"1\"}\n    ]\n</code></pre>"},{"location":"tests/conftest/#tests.conftest.large_sample_graph","title":"<code>large_sample_graph(large_sample_edges)</code>","text":"<p>Provide a large NetworkX graph for testing.</p> <p>This fixture uses the <code>large_sample_edges</code> fixture to create a NetworkX undirected graph. Each edge in the graph is created by connecting the nodes defined in the edge list.</p> <p>Parameters:</p> Name Type Description Default <code>large_sample_edges</code> <code>list[dict]</code> <p>A list of edges, where each edge is a dictionary                              with \"user\" and \"friend\" keys.</p> required <p>Returns:</p> Type Description <p>networkx.Graph: A NetworkX graph constructed from the provided edge list.</p> Source code in <code>tests/conftest.py</code> <pre><code>@pytest.fixture\ndef large_sample_graph(large_sample_edges):\n    \"\"\"\n    Provide a large NetworkX graph for testing.\n\n    This fixture uses the `large_sample_edges` fixture to create a NetworkX undirected graph.\n    Each edge in the graph is created by connecting the nodes defined in the edge list.\n\n    Args:\n        large_sample_edges (list[dict]): A list of edges, where each edge is a dictionary\n                                         with \"user\" and \"friend\" keys.\n\n    Returns:\n        networkx.Graph: A NetworkX graph constructed from the provided edge list.\n    \"\"\"\n    graph = nx.Graph()\n    for edge in large_sample_edges:\n        graph.add_edge(int(edge[\"user\"]), int(edge[\"friend\"]))\n    return graph\n</code></pre>"},{"location":"tests/test_data_loader/","title":"Data Loader Test","text":""},{"location":"tests/test_data_loader/#tests.test_data_loader.TestDataLoader","title":"<code>TestDataLoader</code>","text":"<p>               Bases: <code>TestCase</code></p> <p>Test suite for the DataLoader class.</p> <p>This class contains unit tests for the methods in the DataLoader class, including testing CSV loading, data transformation, and JSON conversion.</p> Source code in <code>tests/test_data_loader.py</code> <pre><code>class TestDataLoader(unittest.TestCase):\n    \"\"\"\n    Test suite for the DataLoader class.\n\n    This class contains unit tests for the methods in the DataLoader class,\n    including testing CSV loading, data transformation, and JSON conversion.\n    \"\"\"\n\n    @patch(\"builtins.open\", new_callable=mock_open, read_data=\"user friend\\nuser1 friend1\\nuser2 friend1\") #mock dla funkcji open w DataLoader.load_csv\n    def test_load_csv(self, mock_file):\n        \"\"\"\n        Test the load_csv method of DataLoader.\n\n        This test uses a mock for the `open` function to simulate reading a CSV file.\n        It ensures that the `load_csv` method correctly parses the data into a list of dictionaries.\n\n        Args:\n            mock_file (unittest.mock.MagicMock): Mocked open function.\n\n        Asserts:\n            The output of `DataLoader.load_csv` matches the expected list of dictionaries.\n        \"\"\"\n        loader = DataLoader(\"dummy_path.csv\")\n        data = loader.load_csv()\n        expected_data = [{'user': 'user1', 'friend': 'friend1'}, {'user': 'user2', 'friend': 'friend1'}]\n        self.assertEqual(data, expected_data) #result from mock == expected\n\n    def test_transform_data(self):\n        \"\"\"\n        Test the transform_data method of DataLoader.\n\n        This test verifies that the `transform_data` method transforms input data into the expected\n        node and edge format for further processing.\n\n        Asserts:\n            The output of `DataLoader.transform_data` matches the expected dictionary\n            containing nodes and edges.\n        \"\"\"\n        loader = DataLoader(\"dummy_path.csv\")\n        data = [{'user': 'user1', 'friend': 'friend1'}, {'user': 'user2', 'friend': 'friend1'}] \n        transformed_data = loader.transform_data(data)\n        expected_data = {\n        \"nodes\": [{\"user\": \"user1\"}, {\"user\": \"user2\"}],\n        \"edges\": [{\"user\": \"user1\", \"friend\": \"friend1\"}, {\"user\": \"user2\", \"friend\": \"friend1\"}]\n        }\n        self.assertEqual(transformed_data, expected_data)\n\n    def test_convert_to_json(self):\n        \"\"\"\n       Test the convert_to_json method of DataLoader.\n\n       This test verifies that the `convert_to_json` method correctly converts\n       the data dictionary to a JSON string.\n\n       Asserts:\n           The output of `DataLoader.convert_to_json` matches the expected JSON string.\n       \"\"\"\n        loader = DataLoader(\"dummy_path.csv\")  \n        data = {\n            \"nodes\": [{\"user\": \"user1\"}, {\"user\": \"user2\"}],\n            \"edges\": [{\"user\": \"user1\", \"friend\": \"friend1\"}, {\"user\": \"user2\", \"friend\": \"friend1\"}]\n        } \n\n        json_data = loader.convert_to_json(data)\n\n        expected_json = '{\"nodes\": [{\"user\": \"user1\"}, {\"user\": \"user2\"}], \"edges\": [{\"user\": \"user1\", \"friend\": \"friend1\"}, {\"user\": \"user2\", \"friend\": \"friend1\"}]}'\n\n        self.assertEqual(json_data, expected_json)\n</code></pre>"},{"location":"tests/test_data_loader/#tests.test_data_loader.TestDataLoader.test_convert_to_json","title":"<code>test_convert_to_json()</code>","text":"<p>Test the convert_to_json method of DataLoader.</p> <p>This test verifies that the <code>convert_to_json</code> method correctly converts the data dictionary to a JSON string.</p> Asserts <p>The output of <code>DataLoader.convert_to_json</code> matches the expected JSON string.</p> Source code in <code>tests/test_data_loader.py</code> <pre><code>def test_convert_to_json(self):\n    \"\"\"\n   Test the convert_to_json method of DataLoader.\n\n   This test verifies that the `convert_to_json` method correctly converts\n   the data dictionary to a JSON string.\n\n   Asserts:\n       The output of `DataLoader.convert_to_json` matches the expected JSON string.\n   \"\"\"\n    loader = DataLoader(\"dummy_path.csv\")  \n    data = {\n        \"nodes\": [{\"user\": \"user1\"}, {\"user\": \"user2\"}],\n        \"edges\": [{\"user\": \"user1\", \"friend\": \"friend1\"}, {\"user\": \"user2\", \"friend\": \"friend1\"}]\n    } \n\n    json_data = loader.convert_to_json(data)\n\n    expected_json = '{\"nodes\": [{\"user\": \"user1\"}, {\"user\": \"user2\"}], \"edges\": [{\"user\": \"user1\", \"friend\": \"friend1\"}, {\"user\": \"user2\", \"friend\": \"friend1\"}]}'\n\n    self.assertEqual(json_data, expected_json)\n</code></pre>"},{"location":"tests/test_data_loader/#tests.test_data_loader.TestDataLoader.test_load_csv","title":"<code>test_load_csv(mock_file)</code>","text":"<p>Test the load_csv method of DataLoader.</p> <p>This test uses a mock for the <code>open</code> function to simulate reading a CSV file. It ensures that the <code>load_csv</code> method correctly parses the data into a list of dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>mock_file</code> <code>MagicMock</code> <p>Mocked open function.</p> required Asserts <p>The output of <code>DataLoader.load_csv</code> matches the expected list of dictionaries.</p> Source code in <code>tests/test_data_loader.py</code> <pre><code>@patch(\"builtins.open\", new_callable=mock_open, read_data=\"user friend\\nuser1 friend1\\nuser2 friend1\") #mock dla funkcji open w DataLoader.load_csv\ndef test_load_csv(self, mock_file):\n    \"\"\"\n    Test the load_csv method of DataLoader.\n\n    This test uses a mock for the `open` function to simulate reading a CSV file.\n    It ensures that the `load_csv` method correctly parses the data into a list of dictionaries.\n\n    Args:\n        mock_file (unittest.mock.MagicMock): Mocked open function.\n\n    Asserts:\n        The output of `DataLoader.load_csv` matches the expected list of dictionaries.\n    \"\"\"\n    loader = DataLoader(\"dummy_path.csv\")\n    data = loader.load_csv()\n    expected_data = [{'user': 'user1', 'friend': 'friend1'}, {'user': 'user2', 'friend': 'friend1'}]\n    self.assertEqual(data, expected_data) #result from mock == expected\n</code></pre>"},{"location":"tests/test_data_loader/#tests.test_data_loader.TestDataLoader.test_transform_data","title":"<code>test_transform_data()</code>","text":"<p>Test the transform_data method of DataLoader.</p> <p>This test verifies that the <code>transform_data</code> method transforms input data into the expected node and edge format for further processing.</p> Asserts <p>The output of <code>DataLoader.transform_data</code> matches the expected dictionary containing nodes and edges.</p> Source code in <code>tests/test_data_loader.py</code> <pre><code>def test_transform_data(self):\n    \"\"\"\n    Test the transform_data method of DataLoader.\n\n    This test verifies that the `transform_data` method transforms input data into the expected\n    node and edge format for further processing.\n\n    Asserts:\n        The output of `DataLoader.transform_data` matches the expected dictionary\n        containing nodes and edges.\n    \"\"\"\n    loader = DataLoader(\"dummy_path.csv\")\n    data = [{'user': 'user1', 'friend': 'friend1'}, {'user': 'user2', 'friend': 'friend1'}] \n    transformed_data = loader.transform_data(data)\n    expected_data = {\n    \"nodes\": [{\"user\": \"user1\"}, {\"user\": \"user2\"}],\n    \"edges\": [{\"user\": \"user1\", \"friend\": \"friend1\"}, {\"user\": \"user2\", \"friend\": \"friend1\"}]\n    }\n    self.assertEqual(transformed_data, expected_data)\n</code></pre>"},{"location":"tests/test_maximize_reach/","title":"Maximize Reach Test","text":""},{"location":"tests/test_maximize_reach/#tests.test_maximize_reach.test_calculate_total_reach_bfs","title":"<code>test_calculate_total_reach_bfs(large_sample_graph)</code>","text":"<p>Test the calculate_total_reach_bfs function.</p> <p>This test verifies that the <code>calculate_total_reach_bfs</code> function correctly calculates the total number of reachable nodes and the set of reachable nodes in a graph using Breadth-First Search (BFS).</p> <p>Parameters:</p> Name Type Description Default <code>large_sample_graph</code> <code>Graph</code> <p>A fixture providing a test graph.</p> required Asserts <ul> <li>The total reach count is as expected.</li> <li>The set of reachable nodes matches the expected set.</li> </ul> Source code in <code>tests/test_maximize_reach.py</code> <pre><code>def test_calculate_total_reach_bfs(large_sample_graph):\n    \"\"\"\n    Test the calculate_total_reach_bfs function.\n\n    This test verifies that the `calculate_total_reach_bfs` function correctly calculates\n    the total number of reachable nodes and the set of reachable nodes in a graph using\n    Breadth-First Search (BFS).\n\n    Args:\n        large_sample_graph (networkx.Graph): A fixture providing a test graph.\n\n    Asserts:\n        - The total reach count is as expected.\n        - The set of reachable nodes matches the expected set.\n    \"\"\"\n    # Act\n    reach_count, reach_set = calculate_total_reach_bfs(large_sample_graph, 1, 2)\n\n    # Assert\n    assert reach_count == 7\n    assert reach_set == {2, 3, 4, 5, 6, 8, 10}\n</code></pre>"},{"location":"tests/test_maximize_reach/#tests.test_maximize_reach.test_find_best_tag_bfs","title":"<code>test_find_best_tag_bfs(large_sample_graph)</code>","text":"<p>Test the find_best_tag_bfs function.</p> <p>This test verifies that the <code>find_best_tag_bfs</code> function correctly identifies the best starting node for maximizing reach using BFS, as well as the corresponding reach count and set of reachable nodes.</p> <p>Parameters:</p> Name Type Description Default <code>large_sample_graph</code> <code>Graph</code> <p>A fixture providing a test graph.</p> required Asserts <ul> <li>The best starting node (tag) is correctly identified.</li> <li>The maximum reach count is as expected.</li> </ul> Source code in <code>tests/test_maximize_reach.py</code> <pre><code>def test_find_best_tag_bfs(large_sample_graph):\n    \"\"\"\n    Test the find_best_tag_bfs function.\n\n    This test verifies that the `find_best_tag_bfs` function correctly identifies the\n    best starting node for maximizing reach using BFS, as well as the corresponding reach\n    count and set of reachable nodes.\n\n    Args:\n        large_sample_graph (networkx.Graph): A fixture providing a test graph.\n\n    Asserts:\n        - The best starting node (tag) is correctly identified.\n        - The maximum reach count is as expected.\n    \"\"\"\n    # Act\n    best_tagged, max_reach, reach_set = find_best_tag_bfs(large_sample_graph, 2)\n\n    # Assert\n    assert best_tagged == 1\n    assert max_reach == 7\n</code></pre>"},{"location":"tests/test_shortest_path/","title":"Shortest Path Test","text":""},{"location":"tests/test_shortest_path/#tests.test_shortest_path.test_build_adjacency_list","title":"<code>test_build_adjacency_list(large_sample_edges)</code>","text":"<p>Test the build_adjacency_list function.</p> <p>This test verifies that the <code>build_adjacency_list</code> function correctly constructs an adjacency list representation of a graph from a list of edges.</p> <p>Parameters:</p> Name Type Description Default <code>large_sample_edges</code> <code>list[dict]</code> <p>A fixture providing a list of edges, where each                              edge is represented as a dictionary with \"user\"                              and \"friend\" keys.</p> required Asserts <ul> <li>The adjacency list for specific nodes is correctly constructed.</li> </ul> Source code in <code>tests/test_shortest_path.py</code> <pre><code>def test_build_adjacency_list(large_sample_edges):\n    \"\"\"\n   Test the build_adjacency_list function.\n\n   This test verifies that the `build_adjacency_list` function correctly constructs\n   an adjacency list representation of a graph from a list of edges.\n\n   Args:\n       large_sample_edges (list[dict]): A fixture providing a list of edges, where each\n                                        edge is represented as a dictionary with \"user\"\n                                        and \"friend\" keys.\n\n   Asserts:\n       - The adjacency list for specific nodes is correctly constructed.\n   \"\"\"\n    # Act\n    adjacency_list = build_adjacency_list(large_sample_edges)\n\n    # Assert: Check that the adjacency list for a few users is built correctly\n    assert adjacency_list[\"1\"] == [(\"2\", 1), (\"3\", 1), (\"4\", 1), (\"5\", 1), (\"6\", 1), (\"10\", 1)]\n    assert adjacency_list[\"2\"] == [(\"1\", 1), (\"3\", 1), (\"8\", 1), (\"5\", 1), (\"10\", 1)]\n</code></pre>"},{"location":"tests/test_shortest_path/#tests.test_shortest_path.test_find_shortest_path","title":"<code>test_find_shortest_path(large_sample_edges)</code>","text":"<p>Test the find_shortest_path function.</p> <p>This test verifies that the <code>find_shortest_path</code> function correctly identifies the shortest path between two nodes in a graph represented as an adjacency list.</p> <p>Parameters:</p> Name Type Description Default <code>large_sample_edges</code> <code>list[dict]</code> <p>A fixture providing a list of edges to construct                              the graph's adjacency list.</p> required Asserts <ul> <li>The shortest path between specific nodes is as expected.</li> <li>If no path exists, the function returns None.</li> </ul> Source code in <code>tests/test_shortest_path.py</code> <pre><code>def test_find_shortest_path(large_sample_edges):\n    \"\"\"\n    Test the find_shortest_path function.\n\n    This test verifies that the `find_shortest_path` function correctly identifies the\n    shortest path between two nodes in a graph represented as an adjacency list.\n\n    Args:\n        large_sample_edges (list[dict]): A fixture providing a list of edges to construct\n                                         the graph's adjacency list.\n\n    Asserts:\n        - The shortest path between specific nodes is as expected.\n        - If no path exists, the function returns None.\n    \"\"\"\n    # Arrange: Build adjacency list from sample edges\n    adjacency_list = build_adjacency_list(large_sample_edges)\n\n    # Act: Find the shortest path from user 1 to user 6\n    path = find_shortest_path(adjacency_list, \"1\", \"6\")\n    path2 = find_shortest_path(adjacency_list, \"1\", \"9\")\n    path3 = find_shortest_path(adjacency_list, \"1\", \"7\")\n\n    # Assert: Ensure that the path is correct\n    assert path == [\"1\", \"6\"]\n    assert path2 == [\"1\", \"3\", \"9\"]\n    assert path3 == None\n</code></pre>"},{"location":"usage/data_loader/","title":"Data Loader","text":"<p>Module for loading and transforming social network data.</p> <p>This module provides a <code>DataLoader</code> class with the following functionalities: 1. Load data from a file containing user connections. 2. Convert data to JSON format. 3. Transform data into nodes and edges for use in graph algorithms.</p>"},{"location":"usage/data_loader/#app.data_loader.DataLoader","title":"<code>DataLoader</code>","text":"<p>A class to load and process social network data from a file.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <code>str</code> <p>Path to the file containing the data.</p> Source code in <code>app/data_loader.py</code> <pre><code>class DataLoader:\n    \"\"\"\n    A class to load and process social network data from a file.\n\n    Attributes:\n        file_path (str): Path to the file containing the data.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DataLoader with the file path.\n\n        :param file_path: Path to the file containing the social network data.\n        \"\"\"\n        self.file_path = file_path\n\n    def load_csv(self):\n        \"\"\"\n        Loads data from a CSV file where each row represents a connection between two users.\n        Automatically detects and skips the header row if present.\n\n        :return: List of dictionaries with keys \"user\" and \"friend\".\n        \"\"\"\n        with open(self.file_path, 'r', encoding='utf-8') as file:\n            reader = list(csv.reader(file, delimiter=' '))\n            if len(reader) &gt; 0 and reader[0] == [\"user\", \"friend\"]: #check if there is header\n                reader = reader[1:]\n            return [{\"user\": row[0], \"friend\": row[1]} for row in reader]\n\n    def convert_to_json(self, data):\n        \"\"\"\n        Converts a list of dictionaries into a JSON string.\n\n        :param data: List of dictionaries containing the data to convert.\n        :return: JSON string representing the data.\n        \"\"\"\n        return json.dumps(data)\n\n    def transform_data(self, data):\n        \"\"\"\n        Transforms raw data into nodes and edges suitable for graph processing.\n\n        :param data: List of dictionaries with keys \"user\" and \"friend\".\n        :return: Dictionary with two keys:\n                - \"nodes\": List of unique users (only users, not friends).\n                - \"edges\": List of connections as dictionaries with keys \"user\" and \"friend\".\n        \"\"\"\n        nodes = []\n        edges = []\n\n        unique_users = set([entry[\"user\"] for entry in data])\n\n        for user in unique_users:\n            nodes.append({\"user\": user})\n\n        nodes = sorted(nodes, key=lambda x: x[\"user\"])\n\n        for entry in data:\n            edges.append({\"user\": entry[\"user\"], \"friend\": entry[\"friend\"]})\n\n        return {\n            \"nodes\": nodes,\n            \"edges\": edges\n        }\n</code></pre>"},{"location":"usage/data_loader/#app.data_loader.DataLoader.__init__","title":"<code>__init__(file_path)</code>","text":"<p>Initializes the DataLoader with the file path.</p> <p>:param file_path: Path to the file containing the social network data.</p> Source code in <code>app/data_loader.py</code> <pre><code>def __init__(self, file_path):\n    \"\"\"\n    Initializes the DataLoader with the file path.\n\n    :param file_path: Path to the file containing the social network data.\n    \"\"\"\n    self.file_path = file_path\n</code></pre>"},{"location":"usage/data_loader/#app.data_loader.DataLoader.convert_to_json","title":"<code>convert_to_json(data)</code>","text":"<p>Converts a list of dictionaries into a JSON string.</p> <p>:param data: List of dictionaries containing the data to convert. :return: JSON string representing the data.</p> Source code in <code>app/data_loader.py</code> <pre><code>def convert_to_json(self, data):\n    \"\"\"\n    Converts a list of dictionaries into a JSON string.\n\n    :param data: List of dictionaries containing the data to convert.\n    :return: JSON string representing the data.\n    \"\"\"\n    return json.dumps(data)\n</code></pre>"},{"location":"usage/data_loader/#app.data_loader.DataLoader.load_csv","title":"<code>load_csv()</code>","text":"<p>Loads data from a CSV file where each row represents a connection between two users. Automatically detects and skips the header row if present.</p> <p>:return: List of dictionaries with keys \"user\" and \"friend\".</p> Source code in <code>app/data_loader.py</code> <pre><code>def load_csv(self):\n    \"\"\"\n    Loads data from a CSV file where each row represents a connection between two users.\n    Automatically detects and skips the header row if present.\n\n    :return: List of dictionaries with keys \"user\" and \"friend\".\n    \"\"\"\n    with open(self.file_path, 'r', encoding='utf-8') as file:\n        reader = list(csv.reader(file, delimiter=' '))\n        if len(reader) &gt; 0 and reader[0] == [\"user\", \"friend\"]: #check if there is header\n            reader = reader[1:]\n        return [{\"user\": row[0], \"friend\": row[1]} for row in reader]\n</code></pre>"},{"location":"usage/data_loader/#app.data_loader.DataLoader.transform_data","title":"<code>transform_data(data)</code>","text":"<p>Transforms raw data into nodes and edges suitable for graph processing.</p> <p>:param data: List of dictionaries with keys \"user\" and \"friend\". :return: Dictionary with two keys:         - \"nodes\": List of unique users (only users, not friends).         - \"edges\": List of connections as dictionaries with keys \"user\" and \"friend\".</p> Source code in <code>app/data_loader.py</code> <pre><code>def transform_data(self, data):\n    \"\"\"\n    Transforms raw data into nodes and edges suitable for graph processing.\n\n    :param data: List of dictionaries with keys \"user\" and \"friend\".\n    :return: Dictionary with two keys:\n            - \"nodes\": List of unique users (only users, not friends).\n            - \"edges\": List of connections as dictionaries with keys \"user\" and \"friend\".\n    \"\"\"\n    nodes = []\n    edges = []\n\n    unique_users = set([entry[\"user\"] for entry in data])\n\n    for user in unique_users:\n        nodes.append({\"user\": user})\n\n    nodes = sorted(nodes, key=lambda x: x[\"user\"])\n\n    for entry in data:\n        edges.append({\"user\": entry[\"user\"], \"friend\": entry[\"friend\"]})\n\n    return {\n        \"nodes\": nodes,\n        \"edges\": edges\n    }\n</code></pre>"},{"location":"usage/maximize_reach/","title":"Maximize Reach","text":"<p>Module for calculating and visualizing the reach of a user in a social graph.</p> <p>This module includes functions to: 1. Calculate the total reach of a post when a specific user is tagged. 2. Find the best person to tag to maximize reach. 3. Visualize the subgraph of users impacted by a post.</p>"},{"location":"usage/maximize_reach/#app.maximize_reach.calculate_total_reach_bfs","title":"<code>calculate_total_reach_bfs(graph, author, tagged)</code>","text":"<p>Calculates the reach using BFS when the author tags a specific person. Combines the reach of the author and tagged person, counting unique nodes only.</p> <p>:param graph: NetworkX graph object representing the social network. :param author: ID of the author making the post. :param tagged: ID of the user tagged in the post. :return: A tuple containing the size of the total reach and the set of reached nodes.</p> Source code in <code>app/maximize_reach.py</code> <pre><code>def calculate_total_reach_bfs(graph, author, tagged):\n    \"\"\"\n    Calculates the reach using BFS when the author tags a specific person.\n    Combines the reach of the author and tagged person, counting unique nodes only.\n\n    :param graph: NetworkX graph object representing the social network.\n    :param author: ID of the author making the post.\n    :param tagged: ID of the user tagged in the post.\n    :return: A tuple containing the size of the total reach and the set of reached nodes.\n    \"\"\"\n    # Get friends of the author and tagged person\n    author_friends = set(graph.neighbors(author))\n    tagged_friends = set(graph.neighbors(tagged))\n\n    # Include both the author and the tagged person in the reach\n    total_reach = (author_friends | tagged_friends) - {author}\n    return len(total_reach), total_reach\n</code></pre>"},{"location":"usage/maximize_reach/#app.maximize_reach.find_best_tag_bfs","title":"<code>find_best_tag_bfs(graph, user)</code>","text":"<p>Finds the best person to tag to maximize reach using BFS.</p> <p>:param graph: NetworkX graph object representing the social network. :param user: ID of the user posting. :return: A tuple containing the best user to tag, the size of the maximum reach,          and the set of reached nodes.</p> Source code in <code>app/maximize_reach.py</code> <pre><code>def find_best_tag_bfs(graph, user):\n    \"\"\"\n    Finds the best person to tag to maximize reach using BFS.\n\n    :param graph: NetworkX graph object representing the social network.\n    :param user: ID of the user posting.\n    :return: A tuple containing the best user to tag, the size of the maximum reach,\n             and the set of reached nodes.\n    \"\"\"\n    max_reach = 0\n    best_tagged = None\n    best_reach_set = set()\n\n    # Iterate through all neighbors of the user\n    for friend in graph.neighbors(user):\n        reach, reach_set = calculate_total_reach_bfs(graph, user, friend)\n        if reach &gt; max_reach:\n            max_reach = reach\n            best_tagged = friend\n            best_reach_set = reach_set\n\n    return best_tagged, max_reach, best_reach_set\n</code></pre>"},{"location":"usage/maximize_reach/#app.maximize_reach.visualize_reach","title":"<code>visualize_reach(graph, user, tagged, reach_set)</code>","text":"<p>Visualizes the subgraph containing the author, the tagged person, and the entire reach of the post.</p> <p>:param graph: NetworkX graph object representing the social network. :param user: ID of the user posting. :param tagged: ID of the user tagged in the post. :param reach_set: Set of IDs of users impacted by the post.</p> Source code in <code>app/maximize_reach.py</code> <pre><code>def visualize_reach(graph, user, tagged, reach_set):\n    \"\"\"\n    Visualizes the subgraph containing the author, the tagged person,\n    and the entire reach of the post.\n\n    :param graph: NetworkX graph object representing the social network.\n    :param user: ID of the user posting.\n    :param tagged: ID of the user tagged in the post.\n    :param reach_set: Set of IDs of users impacted by the post.\n    \"\"\"\n    subgraph = graph.subgraph(reach_set)\n    pos = nx.spring_layout(subgraph)\n\n    plt.figure(figsize=(8, 8))\n    nx.draw(subgraph, pos, with_labels=True, node_color='lightblue', edge_color='gray', node_size=500)\n    nx.draw_networkx_nodes(subgraph, pos, nodelist=[user], node_color='green', label=\"Author\")\n    nx.draw_networkx_nodes(subgraph, pos, nodelist=[tagged], node_color='red', label=\"Tagged\")\n    plt.legend()\n    plt.title(f\"Reach of post by {user} tagging {tagged}\")\n    plt.show()\n</code></pre>"},{"location":"usage/shortest_path/","title":"Shortest Path","text":"<p>Module for finding the shortest path and intermediate connections in a social graph.</p> <p>This module includes functions to: 1. Find the shortest path between two users using Dijkstra's algorithm. 2. Build an adjacency list representation of the graph. 3. Identify intermediate connections between two users.</p>"},{"location":"usage/shortest_path/#app.shortest_path.build_adjacency_list","title":"<code>build_adjacency_list(edges)</code>","text":"<p>Builds an adjacency list representation of the graph from the edge list.</p> <p>:param edges: List of edges, each represented as a dictionary {\"user\": x, \"friend\": y}. :return: Adjacency list representation of the graph.</p> Source code in <code>app/shortest_path.py</code> <pre><code>def build_adjacency_list(edges):\n    \"\"\"\n    Builds an adjacency list representation of the graph from the edge list.\n\n    :param edges: List of edges, each represented as a dictionary {\"user\": x, \"friend\": y}.\n    :return: Adjacency list representation of the graph.\n    \"\"\"\n    adjacency_list = {}\n    for edge in edges:\n        user = edge[\"user\"]\n        friend = edge[\"friend\"]\n        adjacency_list.setdefault(user, []).append((friend, 1))\n        adjacency_list.setdefault(friend, []).append((user, 1))\n    return adjacency_list\n</code></pre>"},{"location":"usage/shortest_path/#app.shortest_path.dijkstra_shortest_path","title":"<code>dijkstra_shortest_path(graph, start, target)</code>","text":"<p>Finds the shortest path using Dijkstra's algorithm.</p> <p>:param graph: Graph represented as an adjacency list {node: [(neighbor, weight), ...]}. :param start: Starting node. :param target: Target node. :return: Shortest path as a list of nodes and the total number of connections.</p> Source code in <code>app/shortest_path.py</code> <pre><code>def dijkstra_shortest_path(graph, start, target):\n    \"\"\"\n    Finds the shortest path using Dijkstra's algorithm.\n\n    :param graph: Graph represented as an adjacency list {node: [(neighbor, weight), ...]}.\n    :param start: Starting node.\n    :param target: Target node.\n    :return: Shortest path as a list of nodes and the total number of connections.\n    \"\"\"\n    queue = [(0, start, [])]  # Priority queue: (cost, node, path)\n    visited = set()\n\n    while queue:\n        cost, current_node, path = heapq.heappop(queue)\n\n        if current_node in visited:\n            continue\n\n        visited.add(current_node)\n        path = path + [current_node]\n\n        if current_node == target:\n            return path, cost\n\n        for neighbor, weight in graph.get(current_node, []):\n            if neighbor not in visited:\n                heapq.heappush(queue, (cost + weight, neighbor, path))\n\n    return None, float('inf')\n</code></pre>"},{"location":"usage/shortest_path/#app.shortest_path.find_intermediate_connections","title":"<code>find_intermediate_connections(adjacency_list, user1, user2)</code>","text":"<p>Finds all friends of user1 who can connect to user2 through their own connections.</p> <p>:param adjacency_list: Graph as an adjacency list. :param user1: Starting node. :param user2: Target node. :return: List of intermediate users.</p> Source code in <code>app/shortest_path.py</code> <pre><code>def find_intermediate_connections(adjacency_list, user1, user2):\n    \"\"\"\n    Finds all friends of user1 who can connect to user2 through their own connections.\n\n    :param adjacency_list: Graph as an adjacency list.\n    :param user1: Starting node.\n    :param user2: Target node.\n    :return: List of intermediate users.\n    \"\"\"\n    intermediate_users = []\n    for neighbor, _ in adjacency_list.get(user1, []):\n        path, _ = dijkstra_shortest_path(adjacency_list, neighbor, user2)\n        if path:\n            intermediate_users.append(neighbor)\n    return intermediate_users\n</code></pre>"},{"location":"usage/shortest_path/#app.shortest_path.find_shortest_path","title":"<code>find_shortest_path(adjacency_list, user1, user2)</code>","text":"<p>Finds the shortest path from user1 to user2 using Dijkstra's algorithm.</p> <p>:param adjacency_list: Graph as an adjacency list. :param user1: Starting node. :param user2: Target node. :return: Shortest path as a list of nodes.</p> Source code in <code>app/shortest_path.py</code> <pre><code>def find_shortest_path(adjacency_list, user1, user2):\n    \"\"\"\n    Finds the shortest path from user1 to user2 using Dijkstra's algorithm.\n\n    :param adjacency_list: Graph as an adjacency list.\n    :param user1: Starting node.\n    :param user2: Target node.\n    :return: Shortest path as a list of nodes.\n    \"\"\"\n    if user2 in dict(adjacency_list.get(user1, [])):\n        print(f\"User {user2} is directly connected to User {user1}.\")\n        print(f\"Shortest path: {user1} -&gt; {user2}\")\n        return [user1, user2]\n\n    path, cost = dijkstra_shortest_path(adjacency_list, user1, user2)\n    if path:\n        print(f\"Shortest path from {user1} to {user2} with {cost} connections: {' -&gt; '.join(map(str, path))}\")\n        return path\n\n    print(f\"No path exists between User {user1} and User {user2}.\")\n    return None\n</code></pre>"},{"location":"usage/show_friends/","title":"Show Friends","text":"<p>Module for displaying a user's friends and visualizing their social connections.</p> <p>This module provides functions to: 1. Display the number of friends and their IDs for a given user. 2. Visualize the user's social graph.</p>"},{"location":"usage/show_friends/#app.show_friends.display_user_friends","title":"<code>display_user_friends(graph, user)</code>","text":"<p>Displays the number of friends and all friends of the given user. Additionally, visualizes the user and their friends as a graph.</p> <p>:param graph: NetworkX graph object representing the social network. :param user: ID of the user whose friends will be displayed.</p> Source code in <code>app/show_friends.py</code> <pre><code>def display_user_friends(graph, user):\n    \"\"\"\n    Displays the number of friends and all friends of the given user.\n    Additionally, visualizes the user and their friends as a graph.\n\n    :param graph: NetworkX graph object representing the social network.\n    :param user: ID of the user whose friends will be displayed.\n    \"\"\"\n    if user not in graph:\n        print(f\"User {user} not found in the network.\")\n        return\n\n    friends = list(graph.neighbors(user))\n    if friends:\n        print(f\"User {user} has {len(friends)} friends: {', '.join(map(str, friends))}\")\n        # Visualize the graph\n        visualize_friends_graph(graph, user, friends)\n    else:\n        print(f\"User {user} has no friends.\")\n</code></pre>"},{"location":"usage/show_friends/#app.show_friends.visualize_friends_graph","title":"<code>visualize_friends_graph(graph, user, friends)</code>","text":"<p>Visualizes the user and their friends as a subgraph.</p> <p>:param graph: NetworkX graph object representing the social network. :param user: ID of the user to visualize. :param friends: List of IDs of the user's friends.</p> Source code in <code>app/show_friends.py</code> <pre><code>def visualize_friends_graph(graph, user, friends):\n    \"\"\"\n    Visualizes the user and their friends as a subgraph.\n\n    :param graph: NetworkX graph object representing the social network.\n    :param user: ID of the user to visualize.\n    :param friends: List of IDs of the user's friends.\n    \"\"\"\n    subgraph = nx.Graph()\n    subgraph.add_node(user, color='blue')  # Add the main user with a distinct color\n    for friend in friends:\n        subgraph.add_node(friend, color='green')  # Add friends\n        subgraph.add_edge(user, friend)  # Add edges\n\n    # Set up colors\n    colors = [data['color'] for _, data in subgraph.nodes(data=True)]\n\n    # Draw the graph\n    plt.figure(figsize=(8, 6))\n    pos = nx.spring_layout(subgraph)  # Position nodes for visualization\n    nx.draw(subgraph, pos, with_labels=True, node_color=colors, node_size=500, font_size=10, font_color=\"white\")\n    plt.title(f\"User {user} and their friends\", fontsize=14)\n    plt.show()\n</code></pre>"}]}